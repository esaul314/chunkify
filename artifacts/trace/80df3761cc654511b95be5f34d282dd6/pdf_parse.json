{
  "type": "page_blocks",
  "source_path": "platform-eng-excerpt.pdf",
  "pages": [
    {
      "page": 16,
      "blocks": [
        {
          "text": "Systems administrator Responsible for all aspects of the production operation of software (in-house applications as well as vendor software and OSS) on the company's computers As the internet took off and in-house software became more important to companies' success, these roles started to mutate. The importance of 24/7 operational support For an increasing number of applications initially led to the growth of operations engineering teams, which tended to be filled with a lot of early-career systems administrators—this was the proving ground they had to face before graduating into a less operational role. You still see pockets of operations engineering in companies today, but the role is declining. As the 2000s progressed, software developers adopted the \"Agile\" model of regular releases of incremental functionality, as a better way to get feedback and so ship a better product. Agile brought a challenge to the operations engineering model: with one team taking on all the responsibility for making code changes and pushing for fast release cycles and the other team taking on all the frontline responsibilities when the code had problems, there was some tension. As anyone who lived through it knows, \"some tension\" is putting it mildly; particularly after an outage caused by something that had been \"thrown over the fence,\" there was usually a large amount of finger-pointing about which side was to blame. The problem was that there was generally no clear answer, because Agile had blurred the lines of responsibility. This led to the creation and broad adoption of what the industry now calls DevOps. DevOps was framed as a model to integrate application development and operations activities, and it became associated as much with a culture change as a set of specific technologies or roles to adopt. That being said, the operational work didn't go away, and on the ground teams implemented it in two different ways: Split Keep the separation between operations and development teams, but have the operations team do some amount of development, particularly around creating glue for pushing code to production and integrating it with infrastructure. Thus, the old operations team with operations engineers was now the DevOps team with DevOps engineers. Merged Merge the operations and development teams into one. With this approach, described as \"you build it, you run it,\" everyone who works on a system is on the same team, with all of them sharing in the operational work (the most salient aspect being part of the on-call rotation). While many teams succeeded with 100% software developers, others were more cross-functional, with specialists to own the glue that pushed code to production and integrated with infrastructure. At some companies, these engineers were also called DevOps engineers[8]. In an act of parallel evolution, in about 2004 Google moved away from operations engineering toward something they called site reliability engineering (SRE). In 2015, during the upswing of DevOps popularity, Google published a book on its practices, This caused a lot of excitement because while many companies had been adopting DevOps plenty were struggling with the practical complexities of making it work. With its heavy emphasis on reliability-oriented processes and organizational responsibilities some thought SRE was the silver bullet the industry needed to finally balance operational and development needs enabling the creation of much more reliable systems. We would argue that SRE, as it was originally sold, has not been a widespread success outside of Google. The processes were too heavyweight; their success relied too much on the specific cultural capital and organizational focus that came from Google being the world's biggest search company. This was well summarized by former director of SRE at Google, Dave O'Connor, who after a couple of stints outside Google wrote a post in 2023 titled \"6 Reasons You Don't Need an SRE Team\" that concludes, \"The next stage in removing our production training wheels as an industry is to tear down the fence between SRE and Product Engineering, and make rational investments in reliability as a mindset, based on specific needs.\" There is no getting away from the needs of operating software. Every company that offers online software systems must have operational support for this software during applicable usage times (which may be working hours, 24/7, or somewhere in between). But how do you manage this in the most cost-effective yet sustainable way possible? You want to limit the places where you must have dedicated operations teams (or, using the terminology introduced earlier, \"split\" DevOps/SRE teams) and make it as easy as possible for the developers of the software to deploy and operate it themselves, achieving the initial vision of DevOps. So you've got more application teams, making more choices, over a more complex set of underlying OSS and cloud primitives. Application teams get into this situation because they want to deliver quickly, and using the best systems of the day that fit the problem (or the systems they know best) will help them do that. Plus, if they've gotta own all the operational responsibility for this system themselves, they might as well pick their own poison! Add to this that application engineers with new features are not the only ones wanting to ship as quickly as possible. The increasing surface of internet-accessible systems has led to an escalation of cyberattacks and vulnerability discoveries, which in turn means that infrastructure and OSS are changing faster to address these risks. We've seen upgrade cycles for systems and components move from years to months, and these changes mean work for application teams who must update their glue and retest or even migrate their software in response. The pressure for change has created a swampy mess of glue mixed with the long-term consequences of individual team decisions. Every new greenfield project adds more choices and glue to this bog of complexity, and over time your developers get stuck in the mire. It's hard to navigate, slow to move through, and full of hungry operational alligators (or worse, crocs!). How do you extract yourself from this morass? It's no surprise that we think the answer is platform engineering, and next we will cover the ways in which it helps you do just that. If you've been stuck in the over-general swamp, you can appreciate the intellectual appeal of platform engineering. You're hiring more people in roles like infrastructure, DevTools, DevOps, and SRE engineer, but you never seem able to keep up with the new complexity arising from OSS and cloud systems. Your applications grow more complex, your application developers become less productive, and you need a way out. Building platforms to manage this complexity sounds great. But building platforms takes significant investment. This includes the costs to build and support them, as well as the overhead associated with limiting application teams' choices of OSS and cloud primitives. Additionally, establishing a platform engineering team can incur organizational costs through reorganizations, role changes, and the overhead of rolling out a new focus area for the company. In this section, we explain how platforms and platform engineering will justify these investments and deliver long-term value. The explosion of choice wasn't all bad: greenfield applications can ship much faster now than in the past, and application developers feel more autonomy and ownership when they have systems they enjoy using. These benefits often get forgotten when companies start to focus on reducing the support burden and long-term costs that arise from the diversity of choices. In this situation, the first instinct of leadership is to prescribe a set of standards using appeals to authority. \"Because I am the expert in databases,\" they say, \"I will choose which databases you, the application teams, can use.\" Or, \"I am the architect, so I decide on all of the software tools and packages.\" Or, \"I am the CTO, so I decide everything.\" Inevitably, these experts will struggle to understand the business needs well enough to make optimal choices, and application teams will suffer. Standardization via authority isn't enough. Platform engineering recognizes that modern engineering teams should have systems that they enjoy using, provided by teams that are responsive to them as customers and not just focused on cost reduction or their own support burden. Instead of prescribing a set of standards based on appeals to authority, platform engineering takes a customer-focused product approach that curates a small set of primitives able to meet A broad range of requirements. This requires compromises in light of business realities, incremental delivery of good platform architecture, and a willingness to partner directly with application teams and listen to what they need. When done well, you can point to the demonstrated leverage of partnering to use the platform-provided offerings instead of appealing to the authority of the architect, database administrator, CTO, or platform VP. In this way, you can reduce the number of OSS and cloud primitives used, without the worst consequences of top-down mandates. On top of reducing the number of primitives in use, platform engineering aims to go one step further and reduce the coupling \"glue\" to those that remain. This removes most of the application-level glue, by abstracting the primitives into systemic platform capabilities that are able to meet broader needs. To illustrate this, we'll dive into the common challenge of managing Terraform. OSS and cloud offerings are complex in a lot of ways, with one of the most costly ways being their configuration—the endless lists of parameters that, if not specified correctly, will eventually lead to issues in production. Nowhere is this more of a problem than in cloud configuration, for which the 2024 state-of-the-art tool is an OSS infrastructure as code (IaC) system called Terraform that provides a perfect illustration of how platform engineering addresses the downsides of glue. When application engineering teams all started pushing hard for the smorgasbord of the IaaS cloud, most companies decided that the path of least friction was to give each team the power and responsibility to provision their own individual cloud infrastructure with their own configuration. In practice, that meant they became part-time cloud engineering teams, versed in configuration management and infrastructure provisioning. If you want infrastructure that is repeatable, rebuildable, and can be secured and validated, you need a configuration management and provisioning template like Terraform. So, the common approach was to have application development teams learn Terraform. In our experience, this led to the following progression: 1. Most engineers don't want to learn a whole new toolset for infrequent tasks.\nInfrastructure setup and provisioning are not an everyday core focus—not even for teams doing mature resiliency testing and regularly rebuilding the system from scratch. So, over time the work would get shunted either to unsuspecting new hires, or to the rare engineers who were interested in DevOps. In the best case this would lead to one or two people evolving into infrastructure provision-ing experts who could write Terraform and own all of this for the team. However, most of the time these engineers didn't stick around on application teams for long, which pushed the work back onto new hires, who usually made a mess of it. 2. The shortage, combined with people cobbling together their own Terraform all\nOver the company, often led leadership to centralize the work across multiple teams (or even the whole company). But rather than centralizing with the goal of building a platform, all the Terraform engineers were just pulled into a team that provided Terraform-writing services. 3. These centralized Terraform-writing teams became trapped in a feature shop\nMindset, taking in work requests and pumping them out. This meant no strong developers (the type that can change the structure of the Terraform to provide better abstractions) wanted to be part of it. Over time, the codebase devolved into a spaghetti mess, which slowed down application teams who wanted something slightly out of the norm and eventually created a security nightmare. A better path is to realize that you need to do something more coherent than offer centralized Terraform-writing support, and think about how to evolve this group of experts from a \"glue\" maintenance center into an engineering center that builds things—namely, a platform. This will require you to go one level deeper in understanding your customers' needs, to develop opinions about which solutions to offer rather than just trying to make it easier for people to get access to whatever they want, and to think about what you can build that takes you beyond just the provisioning step. As you move into new models for providing underlying infrastructure, it is important to centralize expertise and create efficiencies. Instead of each engineering team hiring their own DevOps and SRE engineers to support the infrastructure, a platform team can pool these experts and expand their remit to identifying broader solutions for the company. This not only supports the one-off changes but permits their expertise to be leveraged to create platforms that abstract the underlying complexity. This is where the magic starts to happen. We will mention migrations often in this book, as we believe managing migrations is an important part of a platform's value. Applications and primitives have long but independent lifetimes, during which they each undergo many changes. The combination of these changes creates high maintenance costs. Platform engineering reduces these costs by: Reducing the diversity of OSS and cloud systems in use The fewer primitives you have, the less likely it is that you'll need to do a migration because of one. Encapsulating OSS and vendor systems with APIs While platform APIs are often imperfect at encapsulating all aspects of the OSS and vendor systems they leverage, even \"good enough\" APIs that abstract a lot of their implementation will allow the platform to protect its applications from needing to change when the underlying systems change. Creating observability of platform usage Platforms can provide various mechanisms to standardize collection of metadata around both their own use and that of underlying OSS and vendor systems. This visibility into the dependency state of the applications using your platform should allow you to ease the burden of upgrades when those dependencies need to change. Giving ownership of OSS and cloud systems to teams with software developers When APIs are later shown to be imperfect, unlike traditional infrastructure organizations, platform teams have software developers who can write the non-trivial migration tooling that makes the migration transparent to most application teams. The goal of mature DevOps was to simplify accountability through a \"you build it, you own it\" approach. Despite this having been a popular idea for over a decade, many companies have not managed to execute on this model. We believe that, for those that have succeeded, a major contributor to this success is the leverage that their platforms provide through abstracting the operational complexity of underlying dependencies. No one loves being on call. But when teams are only on call for issues caused by their own applications, we have found that a surprising number are willing to take on operational responsibility. After all, why wouldn't they stand behind the business-critical systems they spend their days creating? For too many companies, however, the operational problems caused by the infrastructure, OSS, and its glue completely dominate the problems in the application code itself. An example of this can be seen as applications seeking higher resiliency are deployed across multiple availability zones, cloud regions, or data centers. This leaves application teams exposed to intermittent cloud provider issues such as networking problems, and the 2 a.m. alerts that inevitably follow. Platform engineering addresses this by building resilient abstractions that can handle application failover on behalf of the application teams, reducing the number of late-night wakeup calls they receive. When most of the underlying systems' operational complexity is hidden behind platform abstractions, this complexity can be owned and operated by your platform team. This requires you to limit the options that you support, so that you can push The abstraction boundary upward into a core set of offerings, each handling a broad set of application use cases. It also requires that you have high operational standards within your platform team, so that application teams are comfortable relying on them. Yes, building and operating platforms that handle these issues is hard, especially when it comes to getting application teams to accept limitations on their choices. But the only alternatives are either directly exposing your entire organization to these issues or perpetuating your use of operations teams (by any name), and so in turn perpetuating the accountability problems, negative impact on agile development, and finger-pointing. Focus on Building Platforms If you want to leverage OSS and vendor primitives but reduce the complexity that slows progress later, you need teams that can build platforms to manage those primitives and their complexity. There are four platform-adjacent approaches that are popular today, all of which bring valuable skills to the organization, but none of which are set up to have the combination of focus and skills needed for building platforms. Table 1-1 summarizes these approaches and why they are not adapted to this task. Table 1-1. Platform-adjacent approaches and why they struggle to build platforms Why they struggle to build platforms Infrastructure Robust operation of underlying infrastructure Little focus on abstracting infrastructure to simplify applications, particularly across multiple infrastructure components DevTools Developer productivity up to production delivery Little focus on solving developer productivity challenges related to systems in production running on complex infrastructure DevOps Application delivery to production Little focus on ensuring their automation/tools help the widest possible audience SRE System reliability Little focus on systemic issues other than reliability, often delivering impact through organizational practices instead of developing better systems Individuals from each of these backgrounds might assert that they personally want to build more platforms rather than glue, but their organization won't let them. We empathize; we are not describing individuals, but rather how these approaches have evolved within organizations and how organizations typically define the respective teams' missions. However, the problem remains—individuals' roles are limited by the mission of their team, and changing a team's mission is not easy when the greater organization expects it to just do what it always has done. Platform engineering asks each of these groups of engineers to come out of their silos and work in teams with a broader mission to create platforms that provide balance. This involves:\n• For infrastructure teams, balancing infrastructure capabilities with developer- Centered simplicity\n• For DevTools teams, balancing development experience with production support Experience\n• For DevOps teams, balancing optimal per-application glue with more general\nSoftware to support a lot more applications\n• For SRE teams, balancing reliability with other system attributes like feature\nAgility, cost efficiency, security, and performance As a deliberate reset of organizational expectations, platform engineering gives you the ability to create teams that focus on building the technologies to finally clear the swamp. As you're hopefully starting to see, platforms can cure all kinds of developer pain points, make your systems faster and more secure, make your developers more productive, deal with migrations automatically, and shorten the feedback loops for getting things done. And while we recognize that it can take quite some time to achieve all of these outcomes, we believe that this is an ideal worth striving for. But what about the other good things that a platform might do? We're engineers, after all, so it's natural to expect our platforms to also support innovation and experimentation, because we know that innovation is the growth engine of our companies. Indeed, they can, but we want to clarify what this means, because platforms can get in the way of innovation and experimentation as much as they can support it. If we are speaking purely of business innovation that can be developed within the context of the existing technology offerings, yes, platforms support that innovation. After all, by making application developers more productive, and in particular enabling them to push new features to production safely (such as through the use of feature flags and A/B testing), platforms allow them to build more faster, and thus support rapid experimentation with business ideas using the existing technology. However, there will always be innovations that the platform by its nature does not support, and even fights against. Most significant innovation involving technology is going to require tools that don't exist yet in the company to be brought to bear on a problem. The data space is a great example, because it moves so quickly. You may have an excellent platform that supports easy access to relational databases and enables most of the engineers at the company to do their jobs well. But if a team Realizes they need a storage option with very different performance characteristics than your relational database offering in order to power a new, innovative business opportunity, they are going to leave your platform, at least partially, to build out this idea. If and when it comes to fruition, you may find that the new storage system is a good thing to pull into the platform offerings—but the innovation here is not enabled by the platform! That doesn't mean you should try to cram every new idea into the platform; rather, the best path is often to let these ideas develop independently, then merge in only those that are successful and have widespread demand. It's tempting for platform teams to seek to quash innovation and experimentation that would take people off the platform. Much of the time, these ideas are a waste of engineering effort, driven by the \"not invented here\" bias that drives software engineers everywhere to build and create their own solutions to problems. But in some cases, these teams are right that they need to do something outside of the norm. If the platform team fights against all exceptions to using their offerings, or insists that they be the ones to build all new offerings that the teams might need, they not only push their systems to be too general but also risk inhibiting healthy innovation along the way. So, yes, your platform should support easy experimentation and innovation within the bounds of the known, by making developers more productive and focused on the application layer. But you will not be the be-all, end-all support of innovation, and in fact, if you want to support innovation, you'll need to let some teams go their own way for a while to prove out new ideas. Making smart choices about when to push people toward central offerings and when to let them spin out their own alternative \"shadow platforms \"9 is a key skill for platform engineering leaders, and one we will discuss more in Chapter",
          "source": {
            "filename": "platform-eng-excerpt.pdf",
            "page": 16,
            "location": null
          },
          "type": "paragraph",
          "language": "en",
          "bbox": [
            72.00274658203125,
            457.77166748046875,
            431.9997863769531,
            497.2726745605469
          ]
        }
      ]
    },
    {
      "page": 20,
      "blocks": [
        {
          "type": "paragraph",
          "text": "A broad range of requirements. This requires compromises in light of business reali‐\nties, incremental delivery of good platform architecture, and a willingness to partner\ndirectly with application teams and listen to what they need. When done well, you\ncan point to the demonstrated leverage of partnering to use the platform-provided\nofferings instead of appealing to the authority of the architect, database administrator,\nPlatform VP. In this way you can reduce the number of OSS and cloud\nprimitives used, without the worst consequences of top-down mandates.\nOn top of reducing the number of primitives in use, platform engineering aims\nto go one step further and reduce the coupling “glue” to those that remain. This\nremoves most of the application-level glue, by abstracting the primitives into systemic\nplatform capabilities that are able to meet broader needs. To illustrate this, we’ll dive\ninto the common challenge of managing Terraform.\nOSS and cloud offerings are complex in a lot of ways, with one of the most costly\nways being their configuration—the endless lists of parameters that, if not specified\ncorrectly, will eventually lead to issues in production. Nowhere is this more of a\nproblem than in cloud configuration, for which the 2024 state-of-the-art tool is an\nOSS infrastructure as code (IaC) system called Terraform that provides a perfect\nillustration of how platform engineering addresses the downsides of glue.\nWhen application engineering teams all started pushing hard for the smorgasbord\nof the IaaS cloud, most companies decided that the path of least friction was to give\neach team the power and responsibility to provision their own individual cloud infra‐\nstructure with their own configuration. In practice, that meant they became part-time\ncloud engineering teams, versed in configuration management and infrastructure\nprovisioning. If you want infrastructure that is repeatable, rebuildable, and can be\nsecured and validated, you need a configuration management and provisioning tem‐\nplate like Terraform. So, the common approach was to have application development\nteams learn Terraform. In our experience, this led to the following progression:\n 1. Most engineers don’t want to learn a whole new toolset for infrequent tasks.\n    Infrastructure setup and provisioning are not an everyday core focus—not even\n    for teams doing mature resiliency testing and regularly rebuilding the system\n    from scratch. So, over time the work would get shunted either to unsuspecting\n    new hires, or to the rare engineers who were interested in DevOps. In the best\n    case this would lead to one or two people evolving into infrastructure provision‐\n    ing experts who could write Terraform and own all of this for the team. However,\n    most of the time these engineers didn’t stick around on application teams for\n    long, which pushed the work back onto new hires, who usually made a mess of it.",
          "source": {
            "filename": "platform-eng-excerpt.pdf",
            "page": 20,
            "method": "pdftotext"
          }
        }
      ]
    }
  ]
}